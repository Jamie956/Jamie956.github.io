# 命令


| 命令                       | 说明              |
| -------------------------- | ----------------- |
| npm i gitbook-cli       | 安装 gitbook  |
| touch README.md SUMMARY.md | 创建索引结构      |
| gitbook init               | 生成索引结构文件  |
| gitbook build              | 编译              |
| gitbook serve              | 编译并开启 server |
| npm i gh-pages | 安装 gh-pages |
| gh-pages -d _book | 将文件夹_book 的内容同步到分支 gh-pages |



# 快速开始

```js
npm i
npm run build
npm run serve
npm run sync
```



# java



不提供指针访问内存

JRE（Java Runtime Environment）

字节码（.class 文件）

Java 源代码---->编译器---->jvm 可执行的 Java 字节码(即虚拟指令)---->jvm---->jvm 中解释器----->机器可执行的二进制机器码---->程序运行

装箱：将基本类型用它们对应的引用类型包装起来；
int -> integer

拆箱：将包装类型转换为基本数据类型；
integer -> int

静态方法可以不通过对象进行调用

super() 调用父类构造方法

new运算符创建实例，对象放在堆内存，对象引用放在栈内存，

对象相等，指内存中存放的内容

引用相等，指内存地址

## 特性

```
封装
把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法

继承
使用已存在的类作为基础建立新的类，新类可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类
  1. 子类拥有父类非 private 的属性和方法
  2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
  3. 子类可以用自己的方式实现父类的方法

多态
指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）
```



## 重载，重写

```
重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时　　

重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法
```



## String

|          | String                                                       | StringBuilder                                                | StringBuffer                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
| 可变     | N                                                            | Y                                                            | Y                                                     |
| 线程安全 | Y                                                            | N                                                            | Y(同步锁)                                             |
|          | 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象 | StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险 | StringBuffer 每次都会对 StringBuffer 对象本身进行操作 |
| 使用选择 | 操作少量的数据                                               | 单线程操作字符串缓冲区下操作大量数据                         | 多线程操作字符串缓冲区下操作大量数据                  |



## 接口，抽象类

|      | 接口               | 抽象类           |
| ---- | ------------------ | ---------------- |
| 方法 | 抽象               | 抽象/非抽象      |
| 变量 | final              |                  |
|      | 类实现多个接口     | 类实现一个抽象类 |
|      | 类实现接口所有方法 | 不一定           |
|      | 不能用 new 实例化  |                  |
|      | 行为规范           | 模板设计         |



## 变量

|          | 成员变量                           | 局部变量                 |
| -------- | ---------------------------------- | ------------------------ |
|          | 属于类                             | 在方法中定义/参数        |
| 修饰     | 被 public,private,static 修饰      | 只有final修饰            |
| 存储     | 是对象的一部分，而对象存在于堆内存 | 存在于栈内存             |
| 生存时间 | 随着对象的创建而存在               | 随着方法的调用而自动消失 |
|          | 以类型的默认值而赋值               | 不会自动赋值             |



## 构造方法

1. 名字与类名相同；

2. 没有返回值，但不能用void声明构造函数；

3. 生成类的对象时自动执行，无需调用。

   

## 静态/实例方法

|      | 静态方法                  | 实例方法      |
| ---- | ------------------------- | ------------- |
| 调用 | 类名.方法名/对象名.方法名 | 对象名.方法名 |
|      | 只允许访问静态成员        | 无限制        |

