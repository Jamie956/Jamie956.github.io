### Data structure

**栈**：LIFO，栈顶（栈的末尾，新元素靠近栈顶），栈底（旧元素靠近栈底）

**队列**：FIFO，尾部添加元素，头部移除元素

**链表**：有序元素集合，元素在内存中不连续放置，每个元素由一个自身节点和指向下一个元素的引用（指针/链接）组成

**集合**：无序且唯一

**字典**：key-value

**散列**：hash map

**树**：由 n（n>=1）个有限节点组成一个具有层次关系的集合

**图**：网络结构的抽象模型



### 大

**数据结构**

数据结构：研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作
程序设计 = 数据结构 + 算法

数据：描述客观事物的符号，是计算机中可以操作的对象，能被计算机识别，并输入给计算机处理的符号集合
数据对象：是性质相同的数据元素的集合，是数据的子集
数据元素：组成数据的基本单位
数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位

数据结构：相互之间存在一种或多种特定的数据元素的集合



逻辑结构：数据对象中数据元素之间的相互关系

- 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
- 线性结构：线性结构中的数据元素之间是一对一的关系
- 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系
- 图形结构：图形结构的数据元素是多对多的关系



物理结构：数据的逻辑结构在计算机中的储存形式

- 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
- 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续

数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称

算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
算法的五个基本特性：输入、输出、有穷性、确定性、可行性

算法设计要求：正确性、可读性、健壮性、时间效率高、存储量低



**时间复杂度**

函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，f(n)的增长渐近快于g(n)

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数

某个算法，随着n的增大，它会越来越优于另一种算法，或越来越差于另一算法

T(n)=O(f(n)) 表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度（时间复杂度）



推导大O阶：

- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项存在且不是1，则去除与这个项相乘的常数



对于分支结构，执行次数都是恒定的，不会随n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)

分析算法的复杂度，关键就是分析循环体的运行情况

常数阶O(1)、线性阶O(n)、对数阶O(log<sub>2</sub>n)、平方阶O(n<sup>2</sup>)

时间复杂度耗费时间排列：

O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)



**空间复杂度**

S(n)=O(f(n))，n为问题规模，f(n)为语句关于n所占存储空间的函数



**List**

线性表（List）：0个或多个数据元素的有限序列

地址：存储器中的每个存储单元的编号



**链表**

结点（Node）：数据域+指针域

线性表的链式存储结构：n个结点链结成一个链表

单链表：每个结点只包含一个指针域

头指针：链表中第一个结点的存储位置

头结点：单链表的第一个结点前附设一个结点

插入或删除数据越频繁的操作，单链表的效率优势就越明显



| 结构     | 存储分配方式                                         | 查找 | 插入/删除                          | 空间性能           |
| -------- | ---------------------------------------------------- | ---- | ---------------------------------- | ------------------ |
| 顺序存储 | 用一段连续的存储单元依次存储线性表的数据元素         | O(1) | 平均移动表长一半的元素，O(n)       | 预先分配存储空间   |
| 单链表   | 用链式存储结构，用一组任意的存储单元存放线性表的元素 | O(n) | 找出某位置指针后，插入和删除为O(1) | 不需要分配存储空间 |



**循环链表**

循环链表（Circular Linkedlist）：将单链表中终端结点的指针端由空指针改为指向头结点，使整个单链表形成一个环



双向链表：结点都有两个指针域，一个指向直接后继，一个指向直接前驱



线性表

- 顺序存储结构
- 链式存储结构
  - 单链表
  - 静态链表
  - 循环链表
  - 双向链表



**栈**（stack）：限定仅在表尾进行插入和删除操作的线性表

栈顶（top）：允许插入和删除的一端

栈底（bottom）

后进先出（Last In First Out）

栈的插入操作/进栈/压栈/入栈

栈的删除操作/出栈/弹栈



栈的链式存储结构（链栈）



| 栈     | 时间复杂度 |                                |
| ------ | ---------- | ------------------------------ |
| 顺序栈 | O(1)       | 预先确定长度，读取方便         |
| 链栈   | O(1)       | 每个元素都有指针域，长度无限制 |



递归函数：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数

每个递归定义必须至少有一个条件，满足时递归不再进行，既不再引用自身而是返回值退出



逆波兰：一种不需要括号的后缀表达法，从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将栈顶两个数字出栈，进行运算，运算结果进栈，直到获得结果



中缀表达式转后缀表达式：



**队列**

队列（queue）：只允许在一端进行插入操作（队尾），另一端进行删除操作（队头）的线性表

先进先出（First In First Out）



串（string）：由零个或多个字符组成的有限序列，字符串

串的模式匹配：子串的定位操作



KMP模式匹配算法：



**树**

Tree：是n个(n>=0)个结点的有限集。n=0时为空树。任意一棵非空树种：(1)有且仅有一个特定的跟结点(Root);(2)当n>1时，其余结点可分为m(m>0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且成为根的子树(SubTree)



结点的度(Degree)：结点拥有的子树数

叶(Leaf)/终端点：Degree=0的结点

非终端点/分支结点：Degree!=0的结点，除了根结点，分支结点也叫内部结点

树的度：树内各结点的度的最大值



结点之间的关系：Child, Parent, Sibling

结点的层次(Level)：从根开始定义起，根为第一层

树的深度(Depth)/高度：树中结点的最大层次

有序树：将树中结点的各子树看成从左至右是有次序的，不能互换



特殊二叉树：斜树、满二叉树、完全二叉树



二叉树遍历：

- 前序遍历：访问根结点，先遍历左子树，再遍历右子树
- 中序遍历
- 后序遍历
- 层序遍历

已知前序遍序列和中序遍历序列，可以唯一确定一棵二叉树

已知后序遍序列和中序遍历序列，可以唯一确定一棵二叉树