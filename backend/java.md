## 装箱/拆箱

|          | 装箱(Boxing)                                     | 拆箱(Unboxing)                                         |
| -------- | ------------------------------------------------ | ------------------------------------------------------ |
| 定义     | 将基本数据类型转换为包装器类型                   | 将包装器类型转换为基本数据类型                         |
| 实现     | int i = 1;<br />Integer rs = Integer.valueOf(i); | Integer i = new Integer(1);<br/>int rs = i.intValue(); |
| 自动转换 | Integer a = 1;                                   | int b = new Integer(1);                                |



- Integer.valueOf()

```java
public static Integer valueOf(int i) {
    if(i >= -128 && i <= IntegerCache.high)
        return IntegerCache.cache[i + 128];
    else
        return new Integer(i);
}
```



## 对象创建过程

1. new 类名
2. 根据new的参数在常量池中定位一个类的符号引用
3. 如果没有找到这个符号引用，说明类还没被加载，则进行类的加载、解析和初始化
4. 虚拟机为对象分配堆内存
5. 将分配的内存初始化为零值
6. 设置对象头，Mark Word (HashCode、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄)，类型指针
7. 调用对象的init方法



## 类加载

1. 装载：由类加载器完成，将.class文件的二进制文件载入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象，作为该类访问入口
2. 链接：分三步			
   1. 校验：确认此二进制文件是否适合当前的JVM
   2. 准备：为静态成员分配内存空间，并设置默认值
   3. 解析：转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系）
3. 初始化：执行类中定义的java程序代码（类构造器）
4. 卸载：没有任何引用指向Class对象时就会被卸载



### 加载器

- 启动类加载器 Bootstrap ClassLoader：加载<JAVA_HOME>\lib目录下核心库

- 扩展类加载器 Extension ClassLoader：加载<JAVA_HOME>\lib\ext目录下扩展包

- 应用程序类加载器 Application ClassLoader：  加载用户路径(classpath)上指定的类库



### 双亲委派模型

如果一个类加载器收到类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成

1. 当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成

2. 当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成

3. 如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载

4. 如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载

5. 如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载

6. 如果均加载失败，就会抛出ClassNotFoundException异常



## 封装

把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法



## 继承

使用已存在的类作为基础建立新的类，新类可以增加新的数据或新的功能，也可以用父类的功能

1. 子类拥有父类非 private 的属性和方法
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方式实现父类的方法



## 多态

指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）



## 重载

发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同



## 重写

发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法



## String

|          | String                                                       | StringBuilder                                                | StringBuffer                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------- |
| 可变     | N                                                            | Y                                                            | Y                                        |
| 线程安全 | Y                                                            | N                                                            | Y(同步锁)                                |
|          | 创建 String 类型的对象时，虚拟机到常量池查找是否有相同的值的对象，如果有就赋值给当前引用，否则在常量池创建一个String对象 | 比使用 StringBuffer 获得 10%~15% 左右的性能提升，但有线程安全问题 | 每次都会对 StringBuffer 对象本身进行操作 |
| 应用场景 | 操作少量的数据                                               | 单线程操作字符串缓冲区下操作大量数据                         | 多线程操作字符串缓冲区下操作大量数据     |




## 接口/抽象类

|      | 接口               | 抽象类               |
| ---- | ------------------ | -------------------- |
| 方法 | 抽象               | 抽象/非抽象          |
| 变量 | final              |                      |
|      | 一个类实现多个接口 | 一个类实现一个抽象类 |
|      | 类实现接口所有方法 | 不一定               |
|      | 不能用 new 实例化  |                      |
|      | 行为规范           | 模板设计             |



## 变量

|          | 成员变量                           | 局部变量                 |
| -------- | ---------------------------------- | ------------------------ |
|          | 属于类                             | 在方法中定义/参数        |
| 修饰     | 被 public,private,static 修饰      | 只有final修饰            |
| 存储     | 是对象的一部分，而对象存在于堆内存 | 存在于栈内存             |
| 生存时间 | 随着对象的创建而存在               | 随着方法的调用而自动消失 |
|          | 以类型的默认值而赋值               | 不会自动赋值             |



## 构造方法

1. 名字与类名相同
2. 没有返回值，不能用void声明
3. 生成类的对象时自动执行，无需调用



## == & equal

==：基本数据类型比较值，引用数据类型比较内存地址

equals() ：比较内容



## **线程**

### 定义

在进程中独立运行的子任务

一个进程在其执行的过程中可以产生多个线程，同一个进程中的线程共享其进程中的内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享），相比进程，线程之间的切换效率较高



### 生命周期

1. **新建(new)**：创建Thread实例时，此线程进入新建状态（未被启动）

   ```Thread t1 = new Thread();```

2. **就绪(runnable)**：线程已经被启动，正在等待被分配给CPU时间片，此时线程正在就绪队列中排队等候得到CPU资源

   ```t1.start();```

3. **运行(running)**：线程获得CPU资源正在执行任务，一直运行到结束，除非自动放弃CPU资源或者有优先级更高的线程进入

4. **阻塞(block)**：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行

      1.  sleep：在指定时间后可进入就绪状态
      2.  wait：线程放入等待队列(waitting queue)中

5. **死亡(dead)**：线程执行完毕或被其它线程杀死时，进入死亡状态，这时不能再进入就绪状态

   1.  自然终止：正常运行run()方法后终止
   2.  异常终止：调用**stop()**方法让一个线程终止运行



<img src="https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932" alt="https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932" class="transparent">



### wait/notify

- wait 让当前线程进入等待状态，并且释放锁
- notify 唤醒任意一个正在等待锁的线程，并且让它得到锁
- notifyAll 唤醒所有等待对象锁的线程，如果有多个线程都被唤醒，那么锁将会被他们争夺，同一时间只会有一个线程得到锁



### 常用方法

- `hread.currentThread()` 静态方法，获取当前线程对象；
- `isAlive()` 判断线程是否处于活动状态，即线程已启动且尚未终止；
- `Thread.sleep(long)` 在指定的毫秒数内让当前线程休眠，需要`catch InterruptedException`；
- `Thread.interrupted()` 判断该线程是否中断，执行后将清除中断标志；
- `isInterrupted()` 测试线程是否已经中断；
- `suspend()   resume()  stop()` 暂停、开始和结束线程，不应该使用。暂停方法不会释放资源；
- `yield()` 该线程放弃当前CPU资源，放弃后马上进行CPU竞争；
- `setPriority()`优先级具有继承性，即子线程有父线程的优先级；
  - 高优先级的线程总是大部分先执行完，但不代表高优先级将全部先完成；
  - 优先级较高的不一定每一次都先执行完，具有随机性；
  - 具体的与OS相关；
- `setDaemon()` 设置守护线程，当进程不存在非守护线程时则守护线程将销魂而后进程销毁；



### 非线程安全

存在多个线程对同一个对象中的实例变量进行并发访问控制由此导致的数据脏读；



## 线程池

### 优点

1. 减少创建和销毁线程的次数，重复使用线程
2. 根据系统的承受能力，调整线程池中工作线程的数量，防止消耗过多内存导致服务器崩溃



### ThreadPoolExecutor类

- corePoolSize：默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中
- maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程
- keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize
- unit：参数keepAliveTime的时间单位
- workQueue：一个阻塞队列，用来存储等待执行的任务
- threadFactory：线程工厂，主要用来创建线程
- handler：超出线程范围和队列容量的任务的处理程序

### 实现原理

- 线程池状态
- 任务的执行
  - 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
  - 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
  - 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
  - 如果线程池中的线程数量大于  corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

```java
private final BlockingQueue<Runnable> workQueue; //任务缓存队列，用来存放等待执行的任务
private final ReentrantLock mainLock = new ReentrantLock(); //线程池的主要状态锁，对线程池状态（比如线程池大小，runState等）的改变都要使用这个锁
private final HashSet<Worker> workers = new HashSet<Worker>(); //用来存放工作集
private volatile long  keepAliveTime; //线程存货时间   
private volatile boolean allowCoreThreadTimeOut; //是否允许为核心线程设置存活时间
private volatile int corePoolSize; //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int maximumPoolSize; //线程池最大能容忍的线程数
private volatile int poolSize; //线程池中当前的线程数
private volatile RejectedExecutionHandler handler; //任务拒绝策略
private volatile ThreadFactory threadFactory; //线程工厂，用来创建线程
private int largestPoolSize; //用来记录线程池中曾经出现过的最大线程数
private long completedTaskCount; //用来记录已经执行完毕的任务个数
```

- 线程池中的线程初始化

- 任务缓存队列及排队策略

- 任务拒绝策略

  当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略

```
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
```

- 线程池的关闭
  - shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
  - shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

- 线程池容量的动态调整

### 配置线程池大小

- 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 *N*CPU+1
- 如果是IO密集型任务，参考值可以设置为2**N*CPU



## 锁

### 乐观锁

> 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，提高吞吐量

#### CAS

> CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。



> CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。

### 悲观锁

> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java的synchronized关键字的实现也是悲观锁。

#### 存在问题

1. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
2. 一个线程持有锁会导致其它所有需要此锁的线程挂起。
3. 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

## **程序**

是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码



## **进程**

每个进程是一个应用程序，都有独立的内存空间



是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。



## final

修饰：变量、方法、类。

1. 修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 修饰类，这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3. 修饰方法，防任何继承类修改它



## Servlet

**生命周期：** **Web容器加载Servlet并将其实例化后，Servlet生命周期开始**，容器运行其**init()方法**进行Servlet的初始化；请求到达时调用Servlet的**service()方法**，service()方法会根据需要调用与请求对应的**doGet或doPost**等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的**destroy()方法**。**init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行**。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。



## **static**

1. **修饰成员变量/方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()` 
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别:  非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：1.  它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

SUM

- 静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制



静态方法可以不通过对象进行调用





|      | 静态方法                  | 实例方法      |
| ---- | ------------------------- | ------------- |
| 调用 | 类名.方法名/对象名.方法名 | 对象名.方法名 |
|      | 只允许访问静态成员        | 无限制        |



## this

用于引用类的当前实例



## super

用于子类访问父类的变量和方法





## Arraylist & LinkedList

|              | Arraylist                         | LinkedList           |
| ------------ | --------------------------------- | -------------------- |
| 线程安全     | N                                 | N                    |
| 底层数据结构 | 数组                              | 双向循环链表         |
| 复杂度       | 末尾添加 O(1)，指定位置增删O(n-i) | O(1)                 |
| 随机元素访问 | Y                                 | N                    |
| 内存占用     | 末尾预留空间                      | 每个元素存放前后节点 |



## Design Pattern

### Singleton
定义，保证一个类仅有一个实例，并提供一个访问它的全局访问点。
要点
- 单例类必须要有一个 private 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;
- instance 成员变量和 uniqueInstance 方法必须是 static 的。


饿汉方式。指全局的单例实例在类装载时构建
懒汉方式。指全局的单例实例在第一次被使用时构建。



## 面向对象编程

- 可复用
- 可扩展
- 灵活性好
- 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数
- 面向对象的设计思想是抽象出Class，根据Class创建Instance

### 个人理解

- 把万物的共性抽象出来，比如打工仔，老板，乞丐都是人，人就是他们的共同点，是因为他们具有人的基本特征：眼睛，手指，膝盖等等，把这些特征称作属性，当我们创建人的时候，就会考虑眼睛有多大，手指有多长，这就相当于属性的值，这个我们创建的人就是一个有他自身特点的个体，同理，可以创建第二个，第三个，他们都是基于人这个对象，通过给属性赋值，创建出来，这就说明了对象的复用性

```java
Class Person{
    int eyes;
    int finger;
    Person(int eyes,int finger){
        this.eyes = eyes;
        this.finger = finger;
    }
}

Person p = new Person(3,100);
Person p2 = new Person(5,362);
```

- 打工仔和老板虽然都是人，但是他们有他们自身的特点，不完全是一类人，这时，我们可以对对象进行扩展，既然打工仔是人，老板也是人，那么就可以打工仔继承人，老板继承人，拥有人的共同属性，但是他们又拥有自身的属性，同理，打工仔可以继续细分下去，这说明了对象的扩展性

```java
Class Person{}
Class Boss extends Person{}
Class Employee extends Person{}
```

- 除了继承，还可以把对象的共同行为归纳在一起，称作接口，如果一个类实现了接口，就相当于拥有接口的一套行为规范，比如打工仔和老板都是在同一间公司，写同一个项目的代码。

### 面向过程 & 面向对象

- 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
- 面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。



## Socket编程

- Socket：网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础，由IP和Port组成
- Socket套接字
- Socket原理机制
  -  通信的两端都有Socket
  -  数据在两个Socket间通过IO传输

-  针对网络通信的不同层次，Java提供了不同的API，其提供的网络功能有四大类
  - InetAddress:用于标识网络上的硬件资源，主要是IP地址
  - URL：统一资源定位符，通过URL可以直接读取或写入网络上的数据
  - Sockets：使用TCP协议实现的网络通信Socket相关的类
  - Datagram:使用UDP协议，将数据保存在用户数据报中，通过网络进行通信



- Socket通信步骤

1. 创建ServerSocket和Socket
2. 打开连接到Socket的输入/输出流
3. 按照协议对Socket进行读/写操作
4. 关闭输入输出流、关闭Socket



- 服务器端

1. 创建ServerSocket对象，绑定监听端口
2. 通过accept()方法监听客户端请求
3. 连接建立后，通过输入流读取客户端发送的请求信息
4. 通过输出流向客户端发送乡音信息
5. 关闭相关资源



- 客户端：

1. 创建Socket对象，指明需要连接的服务器的地址和端口号
2. 连接建立后，通过输出流想服务器端发送请求信息
3. 通过输入流获取服务器响应的信息
4. 关闭响应资源



- 应用多线程实现服务器与多客户端之间的通信

1. 服务器端创建ServerSocket，循环调用accept()等待客户端连接
2. 客户端创建一个socket并请求和服务器端连接
3. 服务器端接受若干段请求，创建socket与该客户建立专线连接
4. 建立连接的两个socket在一个单独的线程上对话
5. 服务器端继续等待新的连接







## 反射

### 作用

1. 在运行时判断任意一个对象所属的类；
2. 在运行时获取类的对象；
3.  在运行时访问java对象的属性，方法，构造方法等。





## 题目

1. 

```java
Integer a = 1;
Integer b = 2;
Integer c = 3;
Integer d = 3;
Integer e = 321;
Integer f = 321;
Long g = 3L;
Long h = 2L;

System.out.println(c==d);// true 比较对象，指向cache
System.out.println(e==f);// false 比较对象
System.out.println(c==(a+b));// true 存在表达式，拆箱比较数值
System.out.println(c.equals(a+b));// true 比较数值
System.out.println(g==(a+b));// true 存在表达式，拆箱比较数值
System.out.println(g.equals(a+b));// false a+b调用Integer.valueOf拆箱
System.out.println(g.equals(a+h));// true a+h调用Long.valueOf向上转型
```

解析：

- "=="运算符
  - 两个操作数都是包装器类型的引用 =》比较地址
  - 存在表达式 =》比较数值（自动拆箱）

- equals()不会类型转换



2. 

```java
Double i1 = 100.0;
Double i2 = 100.0;
Double i3 = 200.0;
Double i4 = 200.0;

System.out.println(i1==i2);// false 浮点的值不是有限的
System.out.println(i3==i4);// false
```

